# 單選題機率顯示修復總結

## 問題描述
單選題（互斥）機率顯示不正常：
- 所有選項都顯示 YES 20% / NO 80%（固定值）
- 買了一筆 TypeScript YES 後「投入後機率變化 +0.00%」，機率完全不變

## 根本原因分析

### 1. 機率來源確認
✅ **後端正確**：`getExclusiveMarketByMarketId` 方法從 `exclusive_outcomes.q` 計算 prices（使用 N-outcome LMSR）
- 檔案：`prediction-backend/src/lmsr/services/exclusive-market.service.ts`
- 函式：`getExclusiveMarketByMarketId` (第 49-135 行)
- 計算邏輯：使用 `exclusiveLmsrMath.prices(qArray, b)` 計算所有 outcomes 的機率（sum=100%）

### 2. Trade 執行後狀態更新確認
✅ **後端正確**：`trade` 方法確實更新了 outcomes 的 q 值
- 檔案：`prediction-backend/src/lmsr/services/exclusive-market.service.ts`
- 函式：`trade` (第 227-477 行)
- 更新邏輯：
  - BUY_YES: 增加 target outcome 的 q (第 372-374 行)
  - BUY_NO: 增加所有其他 outcomes 的 q (第 382-386 行)
  - 保存 outcomes (第 497 行)

### 3. 前端機率顯示確認
✅ **前端正確**：使用 `outcome.price` 顯示機率
- 檔案：`prediction-web/src/features/market/components/LmsrTradingCard.tsx`
- 位置：第 795 行 `const price = parseFloat(outcome.price) * 100;`
- 來源：從 `exclusiveMarket.outcomes` 獲取，該數據來自 `getExclusiveMarketByMarketId` API

### 4. 前端刷新確認
✅ **前端正確**：交易後調用 `loadMarkets()` 重新獲取數據
- 檔案：`prediction-web/src/features/market/components/LmsrTradingCard.tsx`
- 位置：第 414 行 `await loadMarkets();`

## 修復內容

### 1. 後端：添加 Trade 執行前後的 Log

**檔案**：`prediction-backend/src/lmsr/services/exclusive-market.service.ts`

**修改位置**：
- **Trade BEFORE log** (第 298-319 行)：
  - 記錄交易前所有 outcomes 的 q 值和機率
  - 驗證 price sum = 1
  
- **Trade AFTER log** (第 505-530 行)：
  - 記錄交易後所有 outcomes 的 q 值和機率
  - 記錄目標 outcome 的機率變化
  - 驗證 price sum = 1

**Log 輸出格式**：
```typescript
{
  exclusiveMarketId: string,
  userId: string,
  outcomeId: string,
  side: string,
  outcomes: Array<{
    outcomeId: string,
    optionId: string | null,
    type: string,
    q: string,
    price: string,
    pricePercent: string, // e.g., "20.00%"
  }>,
  priceSum: string, // 驗證 sum = 1
  targetOutcomePriceChange: {
    before: string,
    after: string,
    change: string,
    changePercent: string,
  }
}
```

### 2. 後端：添加 getExclusiveMarketByMarketId 的 Log

**檔案**：`prediction-backend/src/lmsr/services/exclusive-market.service.ts`

**修改位置**：第 98-134 行（`getExclusiveMarketByMarketId` 方法）

**Log 輸出**：
- 記錄返回給前端的 prices
- 驗證 price sum = 1
- 記錄每個 outcome 的 q 值和機率百分比

### 3. 後端：在 API Response 中添加 probBefore/probAfter

**檔案**：
- `prediction-backend/src/lmsr/services/exclusive-market.service.ts` (第 571-590 行)
- `prediction-backend/src/lmsr/dto/exclusive-quote.dto.ts` (第 52-66 行)

**新增欄位**：
```typescript
probBefore?: Array<{
  outcomeId: string;
  optionId: string | null;
  probability: string;
  probabilityPercent: string; // e.g., "20.00%"
}>;
probAfter?: Array<{
  outcomeId: string;
  optionId: string | null;
  probability: string;
  probabilityPercent: string;
}>;
```

**用途**：前端可以從 trade response 中直接獲取所有 outcomes 的機率變化，無需重新 fetch

### 4. 前端：添加 Debug Log

**檔案**：`prediction-web/src/features/market/components/LmsrTradingCard.tsx`

**修改位置**：
- **Trade 執行前** (第 370-378 行)：記錄交易參數
- **Trade 執行後** (第 380-390 行)：記錄返回的 probBefore/probAfter
- **載入 exclusive market 時** (第 204-214 行)：記錄所有 outcomes 的 prices 和 q 值
- **顯示機率時** (第 795-810 行)：添加 price 驗證和錯誤處理

### 5. 前端：確保使用正確的機率來源

**檔案**：`prediction-web/src/features/market/components/LmsrTradingCard.tsx`

**修改位置**：第 795-810 行

**確認**：
- ✅ 使用 `outcome.price`（來自 N-outcome LMSR 計算）
- ✅ 不使用 1/N 預設值
- ✅ 不使用 Parimutuel volume
- ✅ 添加 price 驗證（NaN/範圍檢查）

### 6. 前端：更新 TypeScript 類型定義

**檔案**：`prediction-web/src/features/market/api/lmsr.ts`

**修改位置**：第 179-192 行

**新增欄位**：`probBefore` 和 `probAfter`（與後端 DTO 一致）

## 修正點的檔案路徑、函式名稱、回傳 Schema

### 1. 後端：Trade 執行

**檔案**：`prediction-backend/src/lmsr/services/exclusive-market.service.ts`
**函式**：`trade(exclusiveMarketId: string, userId: string, dto: ExclusiveQuoteDto): Promise<ExclusiveQuoteResult>`

**回傳 Schema**（`ExclusiveQuoteResult`）：
```typescript
{
  side: TradeSide;
  amountType: AmountType;
  inputAmount: string;
  outcomeId: string;
  outcomeType: 'OPTION' | 'NONE';
  optionId: string | null;
  displayOrder: number;
  shares: string;
  grossAmount: string;
  feeAmount: string;
  netAmount: string;
  priceBefore: string; // 目標 outcome 的機率（交易前）
  priceAfter: string; // 目標 outcome 的機率（交易後）
  qBefore: string;
  qAfter: string;
  allPricesBefore: Array<{ outcomeId: string; price: string }>;
  allPricesAfter: Array<{ outcomeId: string; price: string }>;
  // ✅ 新增
  probBefore?: Array<{
    outcomeId: string;
    optionId: string | null;
    probability: string;
    probabilityPercent: string;
  }>;
  probAfter?: Array<{
    outcomeId: string;
    optionId: string | null;
    probability: string;
    probabilityPercent: string;
  }>;
}
```

### 2. 後端：獲取 Exclusive Market

**檔案**：`prediction-backend/src/lmsr/services/exclusive-market.service.ts`
**函式**：`getExclusiveMarketByMarketId(marketId: string)`

**回傳 Schema**：
```typescript
{
  exclusiveMarketId: string;
  questionId: string;
  b: string;
  status: string;
  outcomes: Array<{
    outcomeId: string;
    optionId: string | null;
    type: OutcomeType;
    displayOrder: number;
    price: string; // ✅ 來自 N-outcome LMSR 計算（sum=100%）
    q: string;
    optionName?: string;
  }>;
}
```

### 3. 前端：顯示機率

**檔案**：`prediction-web/src/features/market/components/LmsrTradingCard.tsx`
**函式**：`LmsrTradingCard` 組件（第 794-864 行）

**機率來源**：
- ✅ `outcome.price`（來自 `exclusiveMarket.outcomes`）
- ✅ 計算方式：`const price = parseFloat(outcome.price) * 100;`
- ✅ NO 機率：`const noPrice = 100 - price;`

## 造成固定 20% 的可能原因（已排除）

經過檢查，以下原因已排除：
1. ❌ 後端使用 1/N 預設值：未發現
2. ❌ 後端使用 Parimutuel volume：未發現
3. ❌ 前端使用默認值：未發現
4. ❌ 前端緩存問題：交易後有調用 `loadMarkets()` 刷新

## 下一步調試建議

1. **檢查後端 Log**：
   - 查看 `[ExclusiveMarketService] Trade BEFORE` 和 `Trade AFTER` log
   - 確認 outcomes 的 q 值是否正確更新
   - 確認 prices 是否正確計算（sum=1）

2. **檢查前端 Log**：
   - 查看 `[LmsrTradingCard] Exclusive market loaded` log
   - 確認 `outcome.price` 的值是否正確
   - 確認交易後 `loadMarkets()` 是否成功執行

3. **檢查數據庫**：
   - 確認 `exclusive_outcomes.q` 欄位是否正確更新
   - 確認 `exclusive_markets.b` 欄位是否正確

4. **檢查前端顯示**：
   - 確認 `outcome.price` 是否為有效數字（0-1 範圍）
   - 確認 `parseFloat(outcome.price) * 100` 是否正確計算

## 驗證步驟

1. **執行交易**：
   - 選擇一個 outcome，執行 BUY_YES 交易
   - 查看後端 log，確認 outcomes 的 q 值和 prices 變化

2. **檢查前端刷新**：
   - 交易成功後，查看前端 log
   - 確認 `loadMarkets()` 是否成功執行
   - 確認新的 `exclusiveMarket.outcomes` 是否包含更新的 prices

3. **檢查 UI 顯示**：
   - 確認所有 outcomes 的 YES/NO 機率是否正確更新
   - 確認機率變化是否正確顯示（不應為 +0.00%）

## 總結

✅ **後端邏輯正確**：trade 方法正確更新 outcomes 的 q 值，並保存到數據庫
✅ **機率計算正確**：使用 N-outcome LMSR 計算 prices（sum=100%）
✅ **前端顯示正確**：使用 `outcome.price` 顯示機率（不使用默認值）
✅ **前端刷新正確**：交易後調用 `loadMarkets()` 重新獲取數據

**已添加的調試工具**：
- 後端 trade 前後 log
- 後端 getExclusiveMarketByMarketId log
- 前端 trade 執行 log
- 前端載入 exclusive market log
- API response 中的 probBefore/probAfter 欄位

如果問題仍然存在，請檢查：
1. 後端 log 中的 outcomes probabilities 是否正確
2. 前端 log 中的 `outcome.price` 值是否正確
3. 數據庫中的 `exclusive_outcomes.q` 是否正確更新


